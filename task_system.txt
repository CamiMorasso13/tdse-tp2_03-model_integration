- task_system.c
Representa el controlador lógico central que define las secuencias del sistema.

Constantes y macros:
 G_TASK_SYS_CNT_INI	         0ul	Valor inicial del contador de ejecución del sistema.
 G_TASK_SYS_TICK_CNT_INI     0ul	Valor inicial del contador de ticks (tiempo).
 DEL_SYS_MIN	             0ul	Tiempo mínimo (base de temporización).
 DEL_SYS_MED	             50ul	Tiempo medio de retardo.
 DEL_SYS_MAX	             500ul	Tiempo máximo de retardo.
Controlan los tiempos de espera entre estados, equivalentes a delays no bloqueantes, implementados con decrementos de ticks.

Estructuras:
task_system_dta -> actúa como la memoria de estado de la máquina de estados del sistema.

Variables globales:
g_task_system_cnt	             uint32_t	Contador global de ciclos de ejecución.
g_task_system_tick_cnt	volatile uint32_t	Contador global de ticks (tiempo base), modificado por interrupciones.

Funciones principales
	task_system_init(void *parameters) -> Inicializa el estado interno del sistema y sus variables. Muestra mensajes informativos con LOGGER_INFO. Inicializa la cola de eventos (init_queue_event_task_system()). Configura el estado inicial. Inicializa los contadores y estructuras (g_task_system_cnt, task_system_dta).
	task_system_update(void *parameters) -> Actualiza el estado del sistema de forma periódica (no bloqueante). Decrementa el tick global. Esta función procesa los eventos y actualiza el estado de la FSM. Permite ejecutar lógica en función del tiempo sin detener el CPU.
	task_system_statechart(void) - > Implementa la máquina de estados finita (FSM) del sistema. Es la función núcleo lógico del módulo.

------------------------------------------------------------------------------------------------------------------------------
-task_system_attribute.h

Define los atributos del sistema de tareas, principalmente para modelar un autómata de estados finitos (FSM, Finite State Machine).
En typedef enum task_system_ev define los eventos del sistema
               EV_SYS_IDLE,
							 EV_SYS_LOOP_DET,
							 EV_SYS_NOT_LOOP_DET,
							 EV_SYS_MANUAL_BTN,
							 EV_SYS_NOT_MANUAL_BTN,
							 EV_SYS_IR_PHO_CELL,
							 EV_SYS_NOT_IR_PHO_CELL
En typedef enum task_system_st se definen los estados del sistema 
               ST_SYS_IDLE,
							 ST_SYS_ACTIVE_01,
							 ST_SYS_ACTIVE_02,
							 ST_SYS_ACTIVE_03,
							 ST_SYS_ACTIVE_04,
							 ST_SYS_ACTIVE_05,
							 ST_SYS_ACTIVE_06

En typedef struct se definen los tipos de datos
	uint32_t: tick
	task_system_st_t: state
	task_system_ev_t: event
	bool: flag

-task_system_interface.h

Inicializa la cola de eventos con init_queue_event_task_system
Agrega un evento a la cola con put_event_task_system
Obtiene el próximo evento en la cola con get_event_task_system
Analiza si hay eventos pendientes en la cola con any_event_task_system

-------------------------------------------------------------------------------------------------------------------------
task_system.png

Maquina de sistema que modela el comportamiento de una barrera, implementada en itemis CREATE.

Estados:

-ST_SYS_IDLE -> El sistema esta en estado de espera 
-ST_SYS_ACTIVE_01 -> Una vez detecte un loop (auto) comienza el proceso esperando a que se precione el boton.
-ST_SYS_ACTIVE_02 -> Una vez precionado el boton comienza a abrirse la barrera.
-ST_SYS_ACTIVE_03 -> Se mantiene arriba la barrera hasta que no detecte el loop (auto).
-ST_SYS_ACTIVE_04 -> No detecta mas el loop significando que auto esta en movimiento.
-ST_SYS_ACTIVE_05 -> No detecte mas el auto en movimiento por el infrarojo.
-ST_SYS_ACTIVE_06 -> Comienza a bajar la barrera volviendo al estado idle y cierra el ciclo.

Eventos:

-EV_SYS_LOOP_DETECTOR -> La placa debajo detecta el auto arriba de ella.
-EV_SYS_MANUAL_BUTON -> Se detecta como el usuario presiona el boton.
-EV_SYS_NOT_LOOP_DETECTOR -> La placa debajo no detecta el auto arriba de ella.
-EV_SYS_IR_PHOTO_CELL -> El infrarojo de la barrera detecta el auto en movimiento por abajo.
-EV_SYS_NOT_IR_PHOTO_CELL -> El infrarojo de la barrera no detecta el auto en movimiento por abajo.
-EV_LED_01_OFF -> Deja de manera apagada la luz led 01.
-EV_LED_02_OFF -> Deja de manera apagada la luz led 02.
-EV_LED_01_ON -> Deja de manera prentida la luz led 01.
-EV_LED_02_ON -> Deja de manera prentida la luz led 02.
-EV_LED_01_BLINK -> Titila la luz led.
Equivalentes a constantes enteras enumeradas (enum) en C.

Acciones:

tick = DEL_SYS_MAX ->inicializa un temporizador al valor máximo permitido.
[tick > DEL_SYS_MIN]/tick-- -> decrementa ese temporizador mientras dure la transición hasta llegar al valor minimo
Corresponden con asignaciones a variables y disparos de eventos.

Tipos de datos:

tick: entero que actúa como contador/temporizador.
Constantes: DEL_SYS_MAX, DEL_SYS_MIN: límites de tiempo configurados (#define o const uint32_t).	
Eventos: Representados como banderas booleanas o como valores de un enum.

____________________________________________________________________________________________________________________________________

Evolucion de g_app_runtime_us

Al iniciar cada ciclo de actualización de la aplicación, g_app_runtime_us se reinicia. Luego, se ejecutan todas las tareas.
Para cada tarea se mide el tiempo de ejecución real en microsegundos usando el DWT cycle counter.
Ese tiempo se acumula en g_app_runtime_us.
Al terminar el ciclo, g_app_runtime_us contiene el tiempo total de CPU consumido por todas las tareas en esa iteración.
En el siguiente ciclo de app_update(), el proceso se repite: se reinicia y vuelve a calcularse.
Comienza en Value = 0 y termina en Value = 20. Al presionar el botón baja a Value = 19 y al soltarlo sube a 20. 

Evolucion WCET

El WCET de cada tarea se pone en cero.
Cada vez que se ejecuta una tarea, se mide cuánto tardó en ese ciclo utilizando cycle_counter_time_us.
Si ese tiempo supera al WCET guardado, se actualiza y si es menor o igual, el WCET no cambia.
Cada WCET (de task_tda_list[x]) comienza en 0.
- WCET del [0] cambia a 12
- WCET del [1] cambia a 4
- WCET del [2] cambia a 4
Luego, al presionar el botón cambian a 14, 7, 5, respectivamente.


